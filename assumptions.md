# Assumptions

## สมมติฐาน (Assumptions)

| Area                | จุดที่ไม่ชัดเจน / ต้องสมมติเอง                                        | สมมติฐานที่กำหนด                                                       | เหตุผล / หมายเหตุ                                                    | Trade-offs (ข้อแลกเปลี่ยน)                                                |
|---------------------|------------------------------------------------------------------------|-------------------------------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------------------|
| Authentication      | ไม่มี requirement เรื่อง login/signup หรือ JWT                        | ไม่มีระบบ Login จริง ใช้ Dev Tool เลือกผู้ใช้                          | ประหยัดเวลา แต่ยังแสดงบทบาท customer/admin ได้                       | ❌ ไม่ปลอดภัยจริง ✅ ทำงานเร็ว เน้นที่ business logic                    |
| User Context        | ไม่ระบุว่า frontend จะส่ง user identity ยังไง                         | ใช้ header `X-User-Id` ส่งไป backend                                    | วิธีง่าย ๆ ในการจำลอง user โดยไม่ต้องทำ auth                         | ❌ ไม่มี session/JWT ✅ ง่ายต่อการสลับผู้ใช้ทดสอบ                        |
| Booking             | ไม่ชัดเจนว่าถ้ายกเลิก booking จะคืน quota หรือไม่                    | การยกเลิก booking จะคืนจำนวนตั๋วกลับเข้าระบบ                           | เพื่อความยุติธรรมและป้องกันความจุหาย                                | ❌ เพิ่ม logic ✅ ทำให้ event capacity ถูกต้องเสมอ                        |
| Ticket Code         | ไม่ได้ระบุรูปแบบ (string, QR code, barcode)                           | ใช้ UUID string เป็น ticket code                                        | ง่ายและ unique พอสำหรับการ demo                                      | ❌ สแกนจริงไม่ได้ ✅ ง่ายและ unique                                       |
| Event Availability  | บอกว่าแสดงตอน page load แต่ไม่ชัดว่าต้อง realtime ไหม               | แสดงเฉพาะตอนโหลดหน้าใหม่ (ไม่ realtime)                               | ลดความซับซ้อน implement ได้เร็ว                                      | ❌ ไม่สดใหม่จริง ✅ ง่าย ไม่ต้องใช้ WebSocket/SSE                        |
| Event Status        | มี enum active/cancelled/completed แต่ไม่บอกวิธีเปลี่ยน               | Admin เป็นผู้เปลี่ยนสถานะเอง                                            | ให้ admin ควบคุมชัดเจน ไม่ต้องทำ job อัตโนมัติ                       | ❌ Manual ✅ ง่ายและชัดเจน                                               |
| Payment             | มี field price, total_amount แต่ไม่พูดถึงการจ่ายจริง                  | ไม่เชื่อม payment gateway เก็บแค่ราคาและยอดรวม                         | นอก scope ของ assignment เน้น DB และ business logic                   | ❌ ไม่มีระบบจ่ายเงินจริง ✅ โฟกัส design/logic                           |
| Constraints         | requirement บอกกว้าง ๆ                                                | เพิ่ม constraint เช่น capacity > 0, quantity > 0, date_time >= ปัจจุบัน| ช่วยให้ข้อมูลใน DB ถูกต้อง                                            | ❌ ไม่ครอบคลุมทุกเคส ✅ ครอบคลุมเคสหลักที่จำเป็น                        |
| Admin Panel         | เขียนว่า admin only แต่ไม่บอกวิธี auth                                | ตรวจสอบ role = admin ใน backend                                         | ลดความซับซ้อน ไม่ต้องทำ auth จริง                                    | ❌ ไม่มีการป้องกันจริง ✅ เพียงพอสำหรับ demo                            |
| Security            | requirement บอกกว้าง ๆ                                                | ตรวจสอบและ sanitize input ขั้นพื้นฐาน                                   | กัน input error เบื้องต้น ส่วน advanced                              | ❌ ไม่มี JWT/CSRF/hashing ✅ เบา ใช้ง่าย                                |
| Event Deletion      | ไม่ระบุว่าถ้า admin ลบ event ผู้ใช้ที่จองไปแล้วจะเจออะไร              | Event ที่ถูกลบยังคงอยู่ใน booking history ของผู้ใช้                      | ป้องกันข้อมูลหาย และยังเห็นประวัติการจองเดิมได้                      | ❌ ข้อมูลบางส่วนคงค้าง ✅ เก็บ history ได้                              |
| Booking Update      | ไม่ระบุว่า PUT /bookings/{id} ใช้แก้อะไรได้บ้าง                      | ใช้สำหรับเปลี่ยน status เท่านั้น (confirmed → cancelled)               | ลดความซับซ้อน ไม่ต้องแก้จำนวนตั๋ว                                    | ❌ แก้ไขไม่ได้เยอะ ✅ ง่ายและตรงไปตรงมา                                |
| Event Statistics    | ไม่ระบุว่ารวม cancelled booking ใน revenue หรือไม่                    | นับเฉพาะ booking ที่ confirmed                                          | ให้ข้อมูลสะท้อนรายได้จริง                                             | ❌ ข้อมูลไม่ครบ ✅ แม่นยำกว่า                                            |
| Booking Confirmation| ไม่บอกว่าต้องเป็นหน้าใหม่ modal หรือ redirect                         | ทำเป็นหน้าใหม่หลังการจองสำเร็จ                                          | ผู้ใช้เห็น ticket code ชัดเจน                                          | ❌ เพิ่มการเปลี่ยนหน้า ✅ UX ชัดเจน                                    |
| Date/Time Handling  | ไม่ระบุ timezone หรือ event เก่าจองได้ไหม                              | ใช้เวลา local server และไม่อนุญาตจองงานที่ผ่านไปแล้ว                   | ป้องกัน booking ที่ไม่สมเหตุสมผล                                       | ❌ ไม่มี multi-timezone ✅ ง่ายและตรงไปตรงมา                             |
| Search & Filter     | ไม่บอกว่าเป็น exact match หรือ partial match                          | ใช้ partial match (LIKE %keyword%)                                      | ทำให้ค้นหาได้ยืดหยุ่นและ user-friendly                               | ❌ ช้ากว่านิดหน่อย ✅ ใช้ง่ายกว่า                                       |
| Pagination          | ไม่พูดถึง pagination สำหรับ /events                                    | ใช้ limit/offset (เช่น 20 ต่อหน้า)                                      | ป้องกันโหลดข้อมูลทั้งหมดในครั้งเดียว                                   | ❌ เพิ่ม logic frontend ✅ ประสิทธิภาพดีขึ้น                            |
| API Response        | ไม่ระบุรูปแบบ response                                                | ใช้รูปแบบ `{ success, data, error }`                                    | ทำให้ debug และเชื่อมกับ frontend ง่ายขึ้น                            | ❌ เพิ่ม boilerplate ✅ ได้มาตรฐาน                                      |
| Concurrency Control | พูดถึงแค่เป็น optional enhancement                                    | ใช้ transaction + optimistic locking                                    | ป้องกัน overbooking เมื่อมีหลายคนจองพร้อมกัน                           | ❌ โค้ดยุ่งขึ้น ✅ Robust กว่ามาก                                       |
| Test Data Seeding   | ไม่ระบุว่าจะให้ใช้ SQL/JSON/Script                                    | ใช้ Python script สร้าง users, events, bookings                          | reset database ได้ง่าย                                                  | ❌ ผูกกับ script ✅ Dev-friendly ใช้งานสะดวก                            |


## About RealTime Ticket Avalible

| ทางเลือก                             | ควรใช้เมื่อไหร่                                                                                 | ข้อดี                                                                              | ข้อเสีย                                                                                                                                   |
| ------------------------------------ | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **WebSocket (ทำเซิร์ฟเวอร์เอง)**     | ต้องการควบคุมโปรโตคอล/พฤติกรรมละเอียดมาก ๆ หรือมีเคสพิเศษที่บริการสำเร็จรูปทำให้ไม่ได้          | Real-time แท้, ปรับแต่งได้สุด, ไม่ผูกกับผู้ให้บริการ                               | ซับซ้อนเรื่อง scaling (sticky session, fan-out, backpressure), ต้องทำ reconnect/auth/monitoring เอง, ถ้าตัวกลางล้ม connection หลุดทั้งฝูง |
| **Interval Polling**                 | โปรเจ็กต์เล็ก/ต้นแบบ ต้องการทำให้เสร็จเร็ว ใช้ REST เดิม ๆ โดยไม่เพิ่ม infra                    | ง่ายสุด, ไม่ต้องเปิดคอนเนกชันค้าง, คุมโหลดได้ด้วย interval                         | ไม่ real-time จริง, ถ้า 10k ผู้ใช้และ interval ถี่จะยิง request มหาศาล, เสี่ยงโหลด DB, UX อาจต้อง “tick” หลอก                             |
| **Pusher / Ably (pusher service)**   | ต้องการ real-time ที่ scale ได้ไว โดยไม่อยากดูแล WebSocket เอง                                  | Managed, รองรับหมื่น+ connections ง่าย, SDK/ฟีเจอร์ pub/sub ครบ                    | มีค่าใช้จ่ายตาม connection/message, ผูกกับผู้ให้บริการ, ต้องออกแบบช่อง/โควตาข้อความดี ๆ                                                   |
| **Firebase (Firestore/Realtime DB)** | สาย serverless, อยากได้ listener แบบ `onSnapshot` + Cloud Functions จัดการ logic/atomic updates | Real-time ง่าย, scale ดีมาก, SDK ครบ, ทำธุรกรรมพื้นฐาน/Rule ได้                    | คิดเงินตาม read/write → ต้องลดการอ่านถี่, ธุรกรรมซับซ้อนอาจต้องโยนเข้า Functions, ผูกกับ ecosystem                                        |
| **Supabase (Postgres + Realtime)**   | ต้องการพลัง Postgres (transaction, FK, constraint) + push realtime จากฐานข้อมูลโดยตรง           | ได้ SQL/transaction แน่น, มี Realtime จาก logical replication, ทำ trigger/RPC ง่าย | Throughput realtime ต้องออกแบบให้เป็น aggregate ไม่สแปม row, มีโควต้า/แผนราคา, ต้องคิดเรื่อง debounce/batch                               |



| ตัวเลือก                       | ง่าย         | Real-time                   | สเกล 10k ผู้ใช้                         | ความเสี่ยงล้ม/ซับซ้อน                         | ค่าบริการ                 |
| ------------------------------ | ------------ | --------------------------- | --------------------------------------- | --------------------------------------------- | ------------------------- |
| WebSocket เซิร์ฟเวอร์เอง       | ยาก          | ดีมาก                       | ต้องจัด cluster/load balancer เอง       | สูง (ต้องทำ reconnect, backpressure, fan-out) | ค่า infra เอง             |
| Interval Polling               | ง่าย         | ไม่ได้ realtime 100% (ขึ้นกับ interval) | 10k จะยิงถี่มากถ้าไม่กระจายเวลา         | ต่ำ                                           | ถูก แต่เสี่ยงโหลด DB      |
| Pusher/Ably (pusher service)   | ง่าย         | ดีมาก                       | เขารับภาระ scale ให้                    | ต่ำ                                           | คิดตาม connection/message |
| Firebase (Firestore/RTDB)      | ค่อนข้างง่าย | ดีมาก                       | scale ดี, SDK ครบ                       | ต่ำ                                           | ตาม read/write            |
| Supabase (Postgres + Realtime) | ค่อนข้างง่าย | ดีมาก                       | ดีระดับหนึ่ง (ใช้ Realtime/replication) | ต่ำ-กลาง                                      | ตามแผนราคา Supabase       |

